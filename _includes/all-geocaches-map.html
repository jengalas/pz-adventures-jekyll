<!-- Geocoder API -->
<link rel="stylesheet" href="https://dashboard.waterdata.usgs.gov/api/geocoder/1.0.1/geocoder.min.css">
<script src="https://dashboard.waterdata.usgs.gov/api/geocoder/1.0.1/geocoder.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet-groupedlayercontrol/dist/leaflet.groupedlayercontrol.min.css" />
<script src="https://unpkg.com/leaflet-groupedlayercontrol/dist/leaflet.groupedlayercontrol.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
<script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet.awesome-markers@2.0.5/dist/leaflet.awesome-markers.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
<script src="https://unpkg.com/leaflet.awesome-markers@2.0.5/dist/leaflet.awesome-markers.js"></script>

<!-- <div class="fullscreen-map-wrapper"> -->
<div id="map" class="map" style="height: 600px;"></div>
<!-- </div> -->

<!-- Load common basemaps -->
<script src="/assets/js/basemaps.js"></script>
<script>
  /* ------------------ Map setup ------------------ */

  const map = L.map('map', { fullscreenControl: true, geocoderControl: true }).setView([48.2, 16.37], 2);

  objBasemaps['OpenStreetMap'].addTo(map); // Assign default basemap

  /* ------------------ Fetch data ------------------ */

  fetch('/assets/data/geocaches.geojson')
    .then(res => res.json())
    .then(data => initMap(data))
    .catch(err => console.error('GeoJSON load error:', err));

  function initMap(geojson) {
    
    /* ------------------ Cluster group (the only real layer) ------------------ */

    const clusterGroup = L.markerClusterGroup({
      showCoverageOnHover: false,
      disableClusteringAtZoom: 18,
      chunkedLoading: true
    }).addTo(map);

    /* ------------------ Create markers one time ------------------ */

    const allMarkers = [];

    const userIcons = {
      "Rich": "r",
      "Zhanna": "z"
    };

    const typeColors = {
      "Found it": "green",
      "Didn't find it": "red",
      "free-exhibition": "blue",
      "paying-exhibition": "orange",
      "paying-demonstration": "purple",
      "unknown": "gray"
    };

    L.geoJSON(geojson, {
      pointToLayer: (feature, latlng) => {
        const marker = L.marker(latlng, {
          icon: getMarkerIcon(
            feature.properties.user,
            feature.properties.eventType
          )
        });

        // Metadata used for AND filtering
        marker.meta = {
          user: feature.properties.user,
          type: feature.properties.eventType
        };

        let date = new Date(feature.properties.date).toLocaleDateString("en-US", { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

        marker.bindPopup(`
      <strong><a href="https://www.geocaching.com/geocache/${feature.properties.gc_link}" target="_blank">${feature.properties.geocache_title}</a></strong><br>
      User: ${feature.properties.user}<br>
      Type: ${feature.properties.eventType}<br>
      Date: ${date}
    `);

        allMarkers.push(marker);
        return marker;
      }
    });

    /* ------------------ Create dummy layers for UI ------------------ 
    Leaflet.GroupedLayerControl is a good fit as a UI, but the key thing to be very explicit about is this:
  
    The plugin only groups checkboxes visually.
    It does NOT change Leafletâ€™s OR logic.
  
    So we will use it only as a control surface, while keeping your central AND-filtering + clustering logic exactly as before.
    These dummy layers never contain markers.
    They exist only to give the control something to toggle. ------------------ */

    const userLayers = {};
    const typeLayers = {};

    geojson.features.forEach(f => {
      userLayers[f.properties.user] ??= L.layerGroup();
      typeLayers[f.properties.eventType] ??= L.layerGroup();
    });

    /* ------------------ Set up grouped control ------------------ */

    const groupedOverlays = {
      "Users": userLayers,
      "Log Types": typeLayers
    };

    L.control.groupedLayers(
      objBasemaps,
      groupedOverlays,
      { collapsed: false }
    ).addTo(map);

    function getMarkerIcon(user, eventType) {
      return L.AwesomeMarkers.icon({
        icon: userIcons[user] || "circle",
        prefix: "fa",
        markerColor: typeColors[eventType] || "gray",
        iconColor: "white"
      });
    }

    /* ------------------ Manage filter state ------------------ */

    // Add dummy layers to map so checkboxes show as checked
    Object.values(userLayers).forEach(layer => map.addLayer(layer));
    Object.values(typeLayers).forEach(layer => map.addLayer(layer));

    // Initialize filter state
    const activeUsers = new Set(Object.keys(userLayers));
    const activeTypes = new Set(Object.keys(typeLayers));

    /* ------------------ Create AND filter ------------------ */

    function applyFilters() {
      clusterGroup.clearLayers();

      allMarkers.forEach(marker => {
        const { user, type } = marker.meta;
        if (activeUsers.has(user) && activeTypes.has(type)) {
          clusterGroup.addLayer(marker);
        }
      });

      // Zoom to fit currently visible markers
      if (clusterGroup.getLayers().length > 0) {
        map.fitBounds(clusterGroup.getBounds(), { padding: [50, 50] });
      }
    }

    /* ------------------ Live counts ------------------ */
    function countUser(user) {
      return allMarkers.filter(m => m.meta.user === user && activeTypes.has(m.meta.type)).length;
    }
    function countType(type) {
      return allMarkers.filter(m => m.meta.type === type && activeUsers.has(m.meta.user)).length;
    }
    function updateCounts() {
      // Select all overlay labels in grouped control
      document.querySelectorAll('.leaflet-control-layers-overlays label').forEach(label => {
        const input = label.querySelector('input');
        if (!input) return;

        // Strip any existing count from the text
        let name = label.querySelector('span')?.textContent || label.textContent;
        name = name.replace(/\s*\(\d+\)$/, '').trim();

        let count = 0;
        if (userLayers[name]) count = countUser(name);
        if (typeLayers[name]) count = countType(name);

        // Update the span or fallback to label text
        const span = label.querySelector('span');
        if (span) {
          span.textContent = `${name} (${count})`;
        } else {
          label.childNodes.forEach(node => {
            if (node.nodeType === 3) node.nodeValue = ` ${name} (${count})`;
          });
        }
      });
    }

    /* ------------------ Control events ------------------ */

    map.on('overlayadd', e => {
      if (userLayers[e.name]) activeUsers.add(e.name);
      if (typeLayers[e.name]) activeTypes.add(e.name);
      applyFilters();
      updateCounts();
    });

    map.on('overlayremove', e => {
      if (userLayers[e.name]) activeUsers.delete(e.name);
      if (typeLayers[e.name]) activeTypes.delete(e.name);
      applyFilters();
      updateCounts();
    });

    /* ------------------ Initial map draw ------------------ */

    applyFilters();
    updateCounts();
  }

</script>