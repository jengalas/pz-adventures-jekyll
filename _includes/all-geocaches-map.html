<!-- Geocoder API -->
<link rel="stylesheet" href="https://dashboard.waterdata.usgs.gov/api/geocoder/1.0.1/geocoder.min.css">
<script src="https://dashboard.waterdata.usgs.gov/api/geocoder/1.0.1/geocoder.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet-groupedlayercontrol/dist/leaflet.groupedlayercontrol.min.css" />
<script src="https://unpkg.com/leaflet-groupedlayercontrol/dist/leaflet.groupedlayercontrol.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
<script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet.awesome-markers@2.0.5/dist/leaflet.awesome-markers.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
<script src="https://unpkg.com/leaflet.awesome-markers@2.0.5/dist/leaflet.awesome-markers.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>

<style>
  .timeline-control {
    font-size: 13px;
  }

  .timeline-control .noUi-target {
    margin-top: 4px;
  }
</style>

<!-- <div class="fullscreen-map-wrapper"> -->
<div id="map" class="map" style="height: 600px;"></div>
<!-- </div> -->

<!-- Load common basemaps -->
<script src="/assets/js/basemaps.js"></script>
<script>

  function parseMDY(dateStr) {
    // Expected format: MM/DD/YYYY
    const [m, d, y] = dateStr.split("/").map(Number);
    return new Date(y, m - 1, d).getTime();
  }

  function formatMDY(ts) {
    const d = new Date(ts);
    return `${d.toLocaleString('default', { month: 'long' })} ${d.getDate()}, ${d.getFullYear()}`;
  }

  /* ------------------ Map setup ------------------ */

  const map = L.map('map', { fullscreenControl: true, geocoderControl: true }).setView([48.2, 16.37], 2);

  objBasemaps['OpenStreetMap'].addTo(map); // Assign default basemap

  /* ------------------ Fetch data ------------------ */

  fetch('/assets/data/geocaches.geojson')
    .then(res => res.json())
    .then(data => initMap(data))
    .catch(err => console.error('GeoJSON load error:', err));

  function initMap(geojson) {

    /* ------------------ Cluster group (the only real layer) ------------------ */

    const clusterGroup = L.markerClusterGroup({
      showCoverageOnHover: false,
      disableClusteringAtZoom: 18,
      chunkedLoading: true
    }).addTo(map);

    /* ------------------ Create markers one time ------------------ */

    const allMarkers = [];

    const userIcons = {
      "Rich": "r",
      "Zhanna": "z"
    };

    const typeColors = {
      "Found it": "green",
      "Didn't find it": "red",
      "Write note": "blue",
      "free-exhibition": "blue",
      "paying-exhibition": "orange",
      "paying-demonstration": "purple",
      "unknown": "gray"
    };

    L.geoJSON(geojson, {
      pointToLayer: (feature, latlng) => {
        const marker = L.marker(latlng, {
          icon: getMarkerIcon(
            feature.properties.user,
            feature.properties.log_type
          )
        });

        // Metadata used for AND filtering
        const timestamp = parseMDY(feature.properties.date);
        marker.meta = {
          user: feature.properties.user,
          type: feature.properties.log_type,
          timestamp
        };

        let date = new Date(feature.properties.date).toLocaleDateString("en-US", { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

        marker.bindPopup(`
      <strong><a href="https://www.geocaching.com/geocache/${feature.properties.gc_link}" target="_blank">${feature.properties.geocache_title}</a></strong><br>
      User: ${feature.properties.user}<br>
      Type: ${feature.properties.log_type}<br>
      Date: ${date}
    `);

        allMarkers.push(marker);
        return marker;
      }
    });

    /* ------------------ Create dummy layers for UI ------------------ 
    Leaflet.GroupedLayerControl is a good fit as a UI, but the key thing to be very explicit about is this:
  
    The plugin only groups checkboxes visually.
    It does NOT change Leaflet’s OR logic.
  
    So we will use it only as a control surface, while keeping the central AND-filtering + clustering logic exactly as before.
    These dummy layers never contain markers.
    They exist only to give the control something to toggle. ------------------ */

    const userLayers = {};
    const typeLayers = {};

    geojson.features.forEach(f => {
      userLayers[f.properties.user] ??= L.layerGroup();
      typeLayers[f.properties.log_type] ??= L.layerGroup();
    });

    /* ------------------ Set up grouped control ------------------ */

    const groupedOverlays = {
      "Users": userLayers,
      "Log Types": typeLayers
    };

    L.control.groupedLayers(
      objBasemaps,
      groupedOverlays,
      { collapsed: false }
    ).addTo(map);

    function getMarkerIcon(user, log_type) {
      return L.AwesomeMarkers.icon({
        icon: userIcons[user] || "circle",
        prefix: "fa",
        markerColor: typeColors[log_type] || "gray",
        iconColor: "white"
      });
    }

    /* ------------------ Manage filter state ------------------ */

    // Add dummy layers to map so checkboxes show as checked
    Object.values(userLayers).forEach(layer => map.addLayer(layer));
    Object.values(typeLayers).forEach(layer => map.addLayer(layer));

    // Initialize filter state
    const activeUsers = new Set(Object.keys(userLayers));
    const activeTypes = new Set(Object.keys(typeLayers));

    /* ------------------ Create AND filter ------------------ */

    function applyFilters() {
      clusterGroup.clearLayers();

      allMarkers.forEach(marker => {
        const { user, type } = marker.meta;
        const t = marker.meta.timestamp;
        if (
          activeUsers.has(user) &&
          activeTypes.has(type) &&
          t >= activeRange[0] &&
          t <= activeRange[1]
        ) {
          clusterGroup.addLayer(marker);
        }
      });

      // Zoom to fit currently visible markers
      if (clusterGroup.getLayers().length > 0) {
        map.fitBounds(clusterGroup.getBounds(), { padding: [150, 150] });
      }
    }

    /* ------------------ Timeline control (inside map) ------------------ */

    const TimelineControl = L.Control.extend({
      options: {
        position: 'bottomleft'
      },

      onAdd() {
        const container = L.DomUtil.create('div', 'leaflet-control timeline-control');
        container.innerHTML = `
      <div style="background:white;padding:8px 18px;border-radius:6px;min-width:460px;text-align:center;">
        <strong>Date range:</strong> 
        <span id="date-range-label"></span>
        <div id="date-slider" style="margin-top:6px;"></div>
      </div>
    `;

        // Prevent map dragging when interacting with slider
        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.disableScrollPropagation(container);

        return container;
      }
    });

    map.addControl(new TimelineControl());

    /* ------------------ Date slider ------------------ */

    const times = allMarkers.map(m => m.meta.timestamp);
    const minTime = Math.min(...times);
    const maxTime = Math.max(...times);

    let activeRange = [minTime, maxTime];

    const slider = document.getElementById("date-slider");
    const rangeLabel = document.getElementById("date-range-label");

    noUiSlider.create(slider, {
      start: [minTime, maxTime],
      connect: true,
      step: 24 * 60 * 60 * 1000,
      range: {
        min: minTime,
        max: maxTime
      },
      tooltips: false
    });

    rangeLabel.textContent = `${formatMDY(minTime)} – ${formatMDY(maxTime)}`;

    slider.noUiSlider.on("update", values => {
      activeRange = values.map(Number);
      rangeLabel.textContent = `${formatMDY(activeRange[0])} – ${formatMDY(activeRange[1])}`;
      applyFilters();
      updateCounts();
    });

    /* ------------------ Live counts ------------------ */
    function countUser(user) {
      return allMarkers.filter(m =>
        m.meta.user === user &&
        activeTypes.has(m.meta.type) &&
        m.meta.timestamp >= activeRange[0] &&
        m.meta.timestamp <= activeRange[1]
      ).length;
    }

    function countType(type) {
      return allMarkers.filter(m =>
        m.meta.type === type &&
        activeUsers.has(m.meta.user) &&
        m.meta.timestamp >= activeRange[0] &&
        m.meta.timestamp <= activeRange[1]
      ).length;
    }
    function updateCounts() {
      // Select all overlay labels in grouped control
      document.querySelectorAll('.leaflet-control-layers-overlays label').forEach(label => {
        const input = label.querySelector('input');
        if (!input) return;

        // Strip any existing count from the text
        let name = label.querySelector('span')?.textContent || label.textContent;
        name = name.replace(/\s*\(\d+\)$/, '').trim();

        let count = 0;
        if (userLayers[name]) count = countUser(name);
        if (typeLayers[name]) count = countType(name);

        // Update the span or fallback to label text
        const span = label.querySelector('span');
        if (span) {
          span.textContent = `${name} (${count})`;
        } else {
          label.childNodes.forEach(node => {
            if (node.nodeType === 3) node.nodeValue = ` ${name} (${count})`;
          });
        }
      });
    }

    /* ------------------ Control events ------------------ */

    map.on('overlayadd', e => {
      if (userLayers[e.name]) activeUsers.add(e.name);
      if (typeLayers[e.name]) activeTypes.add(e.name);
      applyFilters();
      updateCounts();
    });

    map.on('overlayremove', e => {
      if (userLayers[e.name]) activeUsers.delete(e.name);
      if (typeLayers[e.name]) activeTypes.delete(e.name);
      applyFilters();
      updateCounts();
    });

    /* ------------------ Initial map draw ------------------ */

    applyFilters();
    updateCounts();
  }

</script>