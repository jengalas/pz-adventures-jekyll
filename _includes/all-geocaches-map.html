<!-- Geocoder API -->
<link rel="stylesheet" href="https://dashboard.waterdata.usgs.gov/api/geocoder/1.0.1/geocoder.min.css">
<script src="https://dashboard.waterdata.usgs.gov/api/geocoder/1.0.1/geocoder.min.js"></script>
<!-- Grouped Layer Control -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-groupedlayercontrol/dist/leaflet.groupedlayercontrol.min.css" />
<script src="https://unpkg.com/leaflet-groupedlayercontrol/dist/leaflet.groupedlayercontrol.min.js"></script>
<!-- Marker Clusterer -->
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
<script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
<!-- Leaflet AwesomeMarkers -->
<link rel="stylesheet" href="https://unpkg.com/leaflet.awesome-markers@2.0.5/dist/leaflet.awesome-markers.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
<script src="https://unpkg.com/leaflet.awesome-markers@2.0.5/dist/leaflet.awesome-markers.js"></script>
<!-- NoUI Slider -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>

<style>
  .leaflet-control-layers {
    max-height: 300px;
    overflow-y: auto;
  }

  .leaflet-control-layers-scrollbar {
    max-height: 300px;
    overflow-y: auto;
  }

  .timeline-control {
    font-size: 13px;
  }

  .timeline-control .noUi-target {
    margin-top: 4px;
  }
</style>

<!-- <div class="fullscreen-map-wrapper"> -->
<div id="map" class="map" style="height: 600px;"></div>
<!-- </div> -->

<!-- Load common basemaps -->
<script src="/assets/js/basemaps.js"></script>
<script>

  function parseMDY(dateStr) {
    // Expected format: MM/DD/YYYY
    const [m, d, y] = dateStr.split("/").map(Number);
    return new Date(y, m - 1, d).getTime();
  }

  function formatMDY(ts) {
    const d = new Date(ts);
    return `${d.toLocaleString('default', { month: 'long' })} ${d.getDate()}, ${d.getFullYear()}`;
  }

  /* ------------------ Map setup ------------------ */

  const map = L.map('map', { fullscreenControl: true, geocoderControl: true }).setView([48.2, 16.37], 2);

  objBasemaps['OpenStreetMap'].addTo(map); // Assign default basemap

  /* ------------------ Fetch data ------------------ */

  fetch('/assets/data/geocaches.geojson')
    .then(res => res.json())
    .then(data => initMap(data))
    .catch(err => console.error('GeoJSON load error:', err));

  function initMap(geojson) {

    /* ------------------ Cluster group (the only real layer) ------------------ */

    const clusterGroup = L.markerClusterGroup({
      showCoverageOnHover: false,
      disableClusteringAtZoom: 18,
      chunkedLoading: true
    }).addTo(map);

    /* ------------------ Create markers one time ------------------ */

    const allMarkers = [];

    const userIcons = {
      "Rich": "r",
      "Zhanna": "z"
    };

    const typeColors = {
      "Found it": "green",
      "Didn't find it": "red",
      "Write note": "blue",
      "Archive": "gray",
      "Owner Maintenance": "orange",
      "Temporarily Disable Listing": "purple",
      "Enable Listing": "pink",
      "Update Coordinates": "darkgreen"
    };

    function getMarkerIcon(user, log_type) {
      return L.AwesomeMarkers.icon({
        icon: userIcons[user] || "circle",
        prefix: "fa",
        markerColor: typeColors[log_type] || "gray",
        iconColor: "white"
      });
    }

    L.geoJSON(geojson, {
      pointToLayer: (feature, latlng) => {
        const marker = L.marker(latlng, {
          icon: getMarkerIcon(
            feature.properties.user,
            feature.properties.log_type
          )
        });

        // Metadata used for AND filtering
        const timestamp = parseMDY(feature.properties.date);
        marker.meta = {
          user: feature.properties.user,
          type: feature.properties.log_type,
          timestamp
        };

        let date = new Date(feature.properties.date).toLocaleDateString("en-US", { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

        const loglink = `${feature.properties.log_link}`;

        marker.bindPopup(`
          <strong><a href="https://www.geocaching.com/geocache/${feature.properties.gc_link}" target="_blank">${feature.properties.geocache_title}</a></strong><br>
          User: ${feature.properties.user}<br>
          Type: ${feature.properties.log_type}<br>
          Date: ${date}<br>
          <strong><a href="${loglink}" target="_blank">View Log</a></strong>
        `);

        allMarkers.push(marker);
        return marker;
      }
    });

    /* ------------------ Create dummy layers for UI ------------------ 
    Leaflet.GroupedLayerControl is a good fit as a UI, but the key thing to be very explicit about is this:
  
    The plugin only groups checkboxes visually.
    It does NOT change Leaflet’s OR logic.
  
    So we will use it only as a control surface, while keeping the central AND-filtering + clustering logic exactly as before.
    These dummy layers never contain markers.
    They exist only to give the control something to toggle. ------------------ */

    const userLayers = {};
    const typeLayers = {};

    geojson.features.forEach(f => {
      userLayers[f.properties.user] ??= L.layerGroup();
      typeLayers[f.properties.log_type] ??= L.layerGroup();
    });

    /* ------------------ Manage filter state ------------------ */

    const defaultTypes = new Set([  // Start with most common log types checked/shown on map
      "Found it",
      "Write note",
      "Didn't find it"
    ]);

    // Add dummy layers to map so checkboxes show as checked
    Object.entries(userLayers).forEach(([name, layer]) => {
      map.addLayer(layer);
    });

    // Types: only some checked by default
    Object.entries(typeLayers).forEach(([name, layer]) => {
      if (defaultTypes.has(name)) {
        map.addLayer(layer);   // checked
      }
      // else: leave it off (unchecked)
    });

    // Initialize filter state
    const activeUsers = new Set(Object.keys(userLayers));
    const activeTypes = new Set(
      Object.keys(typeLayers).filter(t => defaultTypes.has(t))
    );

    /* ------------------ Create AND filter ------------------ */

    function applyFilters() {
      clusterGroup.clearLayers();

      allMarkers.forEach(marker => {
        const { user, type } = marker.meta;
        const t = marker.meta.timestamp;
        if (
          activeUsers.has(user) &&
          activeTypes.has(type) &&
          t >= activeRange[0] &&
          t <= activeRange[1]
        ) {
          clusterGroup.addLayer(marker);
        }
      });

      // Zoom to fit currently visible markers
      if (clusterGroup.getLayers().length > 0) {
        map.fitBounds(clusterGroup.getBounds(), { padding: [150, 150] });
      }
    }

    /* ------------------ Set up grouped control ------------------ */

    function computeSortedTypeOrder() {
      const typeCounts = getTypeCounts();

      return Object.keys(typeLayers).sort((a, b) => {
        return (typeCounts[b] || 0) - (typeCounts[a] || 0);
      });
    }

    function preventMapScrollOnControl(control) {
      const container = control.getContainer();
      if (!container) return;

      // Prevent map zoom/pan when interacting with the control
      L.DomEvent.disableScrollPropagation(container);
      L.DomEvent.disableClickPropagation(container);

      // Also prevent touch scroll from moving the map
      L.DomEvent.on(container, 'wheel', L.DomEvent.stopPropagation);
      L.DomEvent.on(container, 'mousewheel', L.DomEvent.stopPropagation);
      L.DomEvent.on(container, 'touchstart', L.DomEvent.stopPropagation);
      L.DomEvent.on(container, 'touchmove', L.DomEvent.stopPropagation);
    }

    let groupedControl = null;

    function rebuildGroupedControl(sortedTypes) {
      // Remember whether the control is currently expanded
      let wasExpanded = false;

      if (groupedControl) {
        const container = groupedControl.getContainer();
        if (container && container.classList.contains('leaflet-control-layers-expanded')) {
          wasExpanded = true;
        }
        map.removeControl(groupedControl);
      }

      const orderedTypeLayers = {};
      sortedTypes.forEach(t => {
        orderedTypeLayers[t] = typeLayers[t];
      });

      const orderedUserLayers = {};
      Object.keys(userLayers).forEach(u => {
        orderedUserLayers[u] = userLayers[u];
      });

      const groupedOverlays = {
        "Users": orderedUserLayers,
        "Log Types": orderedTypeLayers
      };

      groupedControl = L.control.groupedLayers(
        objBasemaps,
        groupedOverlays,
        { collapsed: true }
      ).addTo(map);

      preventMapScrollOnControl(groupedControl);

      // Restore expanded state if it was open before
      if (wasExpanded) {
        const newContainer = groupedControl.getContainer();
        if (newContainer) {
          newContainer.classList.add('leaflet-control-layers-expanded');
        }
      }
    }

    lastTypeOrder = computeSortedTypeOrder();
    rebuildGroupedControl(lastTypeOrder);

    function maybeRebuildGroupedControl() {
      const newOrder = computeSortedTypeOrder();

      if (!lastTypeOrder || newOrder.join('|') !== lastTypeOrder.join('|')) {
        lastTypeOrder = newOrder.slice(); // store a copy
        rebuildGroupedControl(newOrder);
      }
    }



    /* ------------------ Timeline control (inside map) ------------------ */

    const TimelineControl = L.Control.extend({
      options: {
        position: 'bottomleft'
      },

      onAdd() {
        const container = L.DomUtil.create('div', 'leaflet-control timeline-control');
        container.innerHTML = `
      <div style="background:white;padding:8px 18px;border-radius:6px;min-width:460px;text-align:center;">
        <strong>Date range:</strong> 
        <span id="date-range-label"></span>
        <div id="date-slider" style="margin-top:6px;"></div>
      </div>
    `;

        // Prevent map dragging when interacting with slider
        L.DomEvent.disableClickPropagation(container);
        L.DomEvent.disableScrollPropagation(container);

        return container;
      }
    });

    map.addControl(new TimelineControl());

    /* ------------------ Date slider ------------------ */

    const times = allMarkers.map(m => m.meta.timestamp);
    const minTime = Math.min(...times);
    const maxTime = Math.max(...times);

    let activeRange = [minTime, maxTime];

    const slider = document.getElementById("date-slider");
    const rangeLabel = document.getElementById("date-range-label");

    noUiSlider.create(slider, {
      start: [minTime, maxTime],
      connect: true,
      step: 24 * 60 * 60 * 1000,
      range: {
        min: minTime,
        max: maxTime
      },
      tooltips: false
    });

    rangeLabel.textContent = `${formatMDY(minTime)} – ${formatMDY(maxTime)}`;

    slider.noUiSlider.on("update", values => {
      activeRange = values.map(Number);
      rangeLabel.textContent = `${formatMDY(activeRange[0])} – ${formatMDY(activeRange[1])}`;
      applyFilters();
      updateCounts();
    });

    /* ------------------ Live counts ------------------ */
    function countUser(user) {
      return allMarkers.filter(m =>
        m.meta.user === user &&
        activeTypes.has(m.meta.type) &&
        m.meta.timestamp >= activeRange[0] &&
        m.meta.timestamp <= activeRange[1]
      ).length;
    }

    function countType(type) {
      return allMarkers.filter(m =>
        m.meta.type === type &&
        activeUsers.has(m.meta.user) &&
        m.meta.timestamp >= activeRange[0] &&
        m.meta.timestamp <= activeRange[1]
      ).length;
    }
    function updateCounts() {
      // Select all overlay labels in grouped control
      document.querySelectorAll('.leaflet-control-layers-overlays label').forEach(label => {
        const input = label.querySelector('input');
        if (!input) return;

        // Strip any existing count from the text
        let name = label.querySelector('span')?.textContent || label.textContent;
        name = name.replace(/\s*\(\d+\)$/, '').trim();

        let count = 0;
        if (userLayers[name]) count = countUser(name);
        if (typeLayers[name]) count = countType(name);

        // Update the span or fallback to label text
        const span = label.querySelector('span');
        if (span) {
          span.textContent = `${name} (${count})`;
        } else {
          label.childNodes.forEach(node => {
            if (node.nodeType === 3) node.nodeValue = ` ${name} (${count})`;
          });
        }
      });
    }

    function getTypeCounts() {
      const counts = {};

      allMarkers.forEach(m => {
        const { user, type } = m.meta;

        // Respect current AND filters (optional)
        if (activeUsers.has(user)) {
          counts[type] = (counts[type] || 0) + 1;
        }
      });

      return counts;
    }

    /* ------------------ Control events ------------------ */

    function onOverlayChange(e, added) {
      if (userLayers[e.name]) {
        added ? activeUsers.add(e.name) : activeUsers.delete(e.name);
      }
      if (typeLayers[e.name]) {
        added ? activeTypes.add(e.name) : activeTypes.delete(e.name);
      }

      applyFilters();
      updateCounts();

      // Only rebuild if sort order actually changed
      setTimeout(() => {
        maybeRebuildGroupedControl();
      }, 0);
    }

    map.on('overlayadd', e => onOverlayChange(e, true));
    map.on('overlayremove', e => onOverlayChange(e, false));


    /* ------------------ Initial map draw ------------------ */

    applyFilters();
    updateCounts();
  }

</script>